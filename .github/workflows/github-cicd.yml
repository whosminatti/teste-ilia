name: Deploy EKS Cluster com Terraform + Grafana com Helm

on:
  push:
    branches:
      - main

env:
  AWS_REGION: us-east-1

jobs:
  terraform-infrastructure:
    name: Deploy AWS Infrastructure
    runs-on: ubuntu-latest
    outputs:
      cluster-name: ${{ steps.cluster-info.outputs.cluster-name }}

    steps:
      - name: Checa repo
        uses: actions/checkout@v3

      - name: Configura AWS credentials
        uses: aws-actions/configure-aws-credentials@v2
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Install Terraform
        uses: hashicorp/setup-terraform@v2
        with:
          terraform_version: 1.5.7
          terraform_wrapper: false

      - name: Terraform Init
        run: terraform init

      - name: Terraform Validate
        run: terraform validate

      - name: Terraform Plan
        run: terraform plan -var-file="main.tfvars" -out=tfplan
      
      - name: Terraform State List
        run: terraform state list
      
      - name: Terraform Destroy
        run: terraform destroy -auto-approve -var-file="main.tfvars"

  #     - name: Terraform Apply
  #       if: github.ref == 'refs/heads/main' && github.event_name == 'push'
  #       run: terraform apply -auto-approve tfplan

  #     - name: cluster info
  #       id: cluster-info
  #       run: |
  #         CLUSTER_NAME=$(terraform output -raw cluster_name || echo "teste-ilia")
  #         echo "cluster-name=${CLUSTER_NAME}" >> $GITHUB_OUTPUT

  #     - name: Aguardando EKS
  #       run: |
  #         echo "Aguardando cluster EKS estar completamente pronto..."
  #         aws eks wait cluster-active --name ${{ steps.cluster-info.outputs.cluster-name }}
          
  #         echo "Aguardando node group estar pronto..."
  #         aws eks wait nodegroup-active --cluster-name ${{ steps.cluster-info.outputs.cluster-name }} --nodegroup-name ${{ steps.cluster-info.outputs.cluster-name }}-node-group

  # kubernetes-deployment:
  #   name: Deploy Kubernetes Resources
  #   runs-on: ubuntu-latest
  #   needs: terraform-infrastructure
  #   if: success()

  #   steps:
  #     - name: Checa repo
  #       uses: actions/checkout@v3

  #     - name: Configura AWS credentials
  #       uses: aws-actions/configure-aws-credentials@v2
  #       with:
  #         aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
  #         aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
  #         aws-region: ${{ env.AWS_REGION }}

  #     - name: Install kubectl
  #       uses: azure/setup-kubectl@v3
  #       with:
  #         version: 'latest'

  #     - name: Install Helm
  #       uses: azure/setup-helm@v4
  #       with:
  #         version: 'latest'

  #     - name: Update kubeconfig
  #       run: |
  #         aws eks update-kubeconfig --name ${{ needs.terraform-infrastructure.outputs.cluster-name }} --region ${{ env.AWS_REGION }}

  #     - name: Verifica conectividade com cluster
  #       run: |
  #         kubectl cluster-info
  #         kubectl get nodes
          
  #     - name: Aguarda nodes estarem prontos
  #       run: |
  #         kubectl wait --for=condition=Ready nodes --all --timeout=300s

  #     - name: Atualiza StorageClass existente para usar EBS CSI
  #       run: |
  #         echo "Verificando StorageClasses disponíveis:"
  #         kubectl get storageclass
          
  #         echo "Removendo StorageClass padrão (se existir)..."
  #         kubectl delete storageclass gp2 --ignore-not-found
    
  #         echo "Aplicando StorageClass..."
  #         kubectl apply -f manifests/storageclass-gp2.yaml

  #     - name: Verifica se EBS CSI Driver está funcionando
  #       run: |
  #         echo "Aguardando pods do EBS CSI Driver..."
  #         kubectl wait --for=condition=ready pod -l app.kubernetes.io/name=aws-ebs-csi-driver -n kube-system --timeout=300s
          
  #         echo "Pods do EBS CSI Driver:"
  #         kubectl get pods -n kube-system -l app.kubernetes.io/name=aws-ebs-csi-driver

  #     - name: Cria namespace monitoring
  #       run: |
  #         kubectl create namespace monitoring --dry-run=client -o yaml | kubectl apply -f -

  #     - name: Testa provisionamento de volume com PVC de teste
  #       run: |
  #         echo "Criando PVC de teste para verificar funcionamento..."
  #         kubectl apply -f manifests/pvc-teste.yaml
          
  #         # Aguarda um tempo e verifica status
  #         sleep 30
  #         kubectl get pvc test-pvc -n monitoring -o wide
  #         kubectl describe pvc test-pvc -n monitoring || true
          
  #         # Limpa teste
  #         kubectl delete pvc test-pvc -n monitoring --ignore-not-found

  #     - name: Cria PVC para Grafana
  #       run: kubectl apply -f manifests/pvc-grafana.yaml

  #     - name: Aguarda PVC estar Bound com timeout maior
  #       run: |
  #         echo "Aguardando PVC ser provisionado (até 10 minutos)..."
  #         timeout 600 bash -c '
  #         while true; do
  #           STATUS=$(kubectl get pvc grafana-pvc -n monitoring -o jsonpath="{.status.phase}" 2>/dev/null || echo "Pending")
  #           echo "Status do PVC: $STATUS"
  #           if [ "$STATUS" = "Bound" ]; then
  #             echo "PVC está Bound!"
  #             break
  #           fi
  #           sleep 15
  #         done'
          
  #         echo "Detalhes do PVC:"
  #         kubectl get pvc grafana-pvc -n monitoring -o wide
  #         kubectl describe pvc grafana-pvc -n monitoring

  #     - name: ServiceAccount do Grafana com annotation IRSA
  #       env:
  #         SA_NAME: grafana-sa
  #         NAMESPACE: monitoring
  #         ROLE_ARN: arn:aws:iam::${{ secrets.AWS_ACCOUNT_ID }}:role/eks-grafana-sa
  #       run: |
  #         if ! kubectl get serviceaccount $SA_NAME -n $NAMESPACE >/dev/null 2>&1; then
  #           echo "Criando ServiceAccount $SA_NAME..."
  #           kubectl create serviceaccount $SA_NAME -n $NAMESPACE
  #         fi
  #         # Adiciona/atualiza annotation do IRSA
  #         kubectl annotate serviceaccount $SA_NAME -n $NAMESPACE eks.amazonaws.com/role-arn=$ROLE_ARN --overwrite

  #     - name: Add Grafana Helm repo and update
  #       run: |
  #         helm repo add grafana https://grafana.github.io/helm-charts
  #         helm repo update

  #     - name: Install/upgrade Grafana Helm chart
  #       run: |
  #         helm upgrade --install my-grafana grafana/grafana --namespace monitoring \
  #           --set persistence.enabled=true \
  #           --set persistence.size=20Gi \
  #           --set persistence.existingClaim=grafana-pvc \
  #           --set adminPassword=${{ secrets.GRAFANA_ADMIN_PASSWORD }} \
  #           --set service.type=LoadBalancer \
  #           --set service.annotations."service\.beta\.kubernetes\.io/aws-load-balancer-type"="nlb" \
  #           --set serviceAccount.create=false \
  #           --set serviceAccount.name=grafana-sa \
  #           --wait --timeout=15m

  #     - name: Checa status recursos
  #       run: |
  #         echo "=== PODS ==="
  #         kubectl get pods -n monitoring
  #         echo "=== PVCs ==="
  #         kubectl get pvc -n monitoring -o wide
  #         echo "=== SERVICES ==="
  #         kubectl get svc -n monitoring
  #         echo "=== STORAGE CLASSES ==="
  #         kubectl get storageclass

  #     - name: Aguarda Grafana estar pronto
  #       run: |
  #         kubectl wait --for=condition=ready pod -l app.kubernetes.io/name=grafana -n monitoring --timeout=600s

  #     - name: Get Grafana LoadBalancer URL
  #       run: |
  #         echo "Aguardando LoadBalancer URL..."
  #         timeout 300 bash -c '
  #         while true; do
  #           GRAFANA_URL=$(kubectl get svc my-grafana -n monitoring -o jsonpath="{.status.loadBalancer.ingress[0].hostname}" 2>/dev/null)
  #           if [ -n "$GRAFANA_URL" ]; then
  #             echo "Grafana disponível em: http://$GRAFANA_URL"
  #             echo "::set-output name=grafana_url::$GRAFANA_URL"
  #             break
  #           fi
  #           echo "Aguardando LoadBalancer..."
  #           sleep 10
  #         done'
  #         echo "Detalhes do serviço:"
  #         kubectl get svc my-grafana -n monitoring -o wide