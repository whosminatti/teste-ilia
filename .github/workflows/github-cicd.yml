name: Deploy EKS Cluster com Terraform + Grafana com Helm

on:
  push:
    branches:
      - main

env:
  AWS_REGION: us-east-1

jobs:
  terraform-infrastructure:
    name: Deploy AWS Infrastructure
    runs-on: ubuntu-latest
    outputs:
      cluster-name: ${{ steps.cluster-info.outputs.cluster-name }}

    steps:
      - name: Checa repo
        uses: actions/checkout@v3

      - name: Configura AWS credentials
        uses: aws-actions/configure-aws-credentials@v2
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Install Terraform
        uses: hashicorp/setup-terraform@v2
        with:
          terraform_version: 1.5.7
          terraform_wrapper: false

      - name: Terraform Init
        run: terraform init

      - name: Terraform Validate
        run: terraform validate

      - name: Terraform Plan
        run: terraform plan -var-file="main.tfvars" -out=tfplan

      - name: Terraform Apply
        if: github.ref == 'refs/heads/main' && github.event_name == 'push'
        run: terraform apply -auto-approve tfplan

      - name: Get cluster info
        id: cluster-info
        run: |
          CLUSTER_NAME=$(terraform output -raw cluster_name || echo "teste-ilia")
          echo "cluster-name=${CLUSTER_NAME}" >> $GITHUB_OUTPUT

      - name: Wait for EKS cluster to be ready
        run: |
          echo "Aguardando cluster EKS estar completamente pronto..."
          aws eks wait cluster-active --name ${{ steps.cluster-info.outputs.cluster-name }}
          
          echo "Aguardando node group estar pronto..."
          aws eks wait nodegroup-active --cluster-name ${{ steps.cluster-info.outputs.cluster-name }} --nodegroup-name ${{ steps.cluster-info.outputs.cluster-name }}-node-group

  kubernetes-deployment:
    name: Deploy Kubernetes Resources
    runs-on: ubuntu-latest
    needs: terraform-infrastructure
    if: success()

    steps:
      - name: Checa repo
        uses: actions/checkout@v3

      - name: Configura AWS credentials
        uses: aws-actions/configure-aws-credentials@v2
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Install kubectl
        uses: azure/setup-kubectl@v3
        with:
          version: 'latest'

      - name: Install Helm
        uses: azure/setup-helm@v4
        with:
          version: 'latest'

      - name: Update kubeconfig
        run: |
          aws eks update-kubeconfig --name ${{ needs.terraform-infrastructure.outputs.cluster-name }} --region ${{ env.AWS_REGION }}

      - name: Verifica conectividade com cluster
        run: |
          kubectl cluster-info
          kubectl get nodes
          
      - name: Aguarda nodes estarem prontos
        run: |
          kubectl wait --for=condition=Ready nodes --all --timeout=300s

      # INSTALAR EBS CSI DRIVER VIA HELM (MELHOR ALTERNATIVA)
      - name: Install EBS CSI Driver via Helm
        run: |
          helm repo add aws-ebs-csi-driver https://kubernetes-sigs.github.io/aws-ebs-csi-driver
          helm repo update

          # Instala o EBS CSI Driver com configuração atualizada
          helm upgrade --install aws-ebs-csi-driver aws-ebs-csi-driver/aws-ebs-csi-driver \
            --namespace kube-system \
            --set controller.serviceAccount.create=true \
            --set controller.serviceAccount.name=ebs-csi-controller-sa \
            --set node.serviceAccount.create=true \
            --set node.serviceAccount.name=ebs-csi-node-sa \
            --wait --timeout=5m

      - name: Verifica e cria StorageClass
        run: |
          echo "Verificando StorageClasses disponíveis:"
          kubectl get storageclass
                  
          # Cria StorageClass se não existir
          if ! kubectl get storageclass gp2 2>/dev/null; then
            echo "Criando StorageClass gp2..."
            cat <<EOF | kubectl apply -f -
            apiVersion: storage.k8s.io/v1
            kind: StorageClass
            metadata:
              name: gp2
            provisioner: ebs.csi.aws.com
            parameters:
              type: gp2
              fsType: ext4
            volumeBindingMode: WaitForFirstConsumer
            allowVolumeExpansion: true
            EOF
          fi

      - name: Verifica se EBS CSI Driver está funcionando
        run: |
          echo "Aguardando pods do EBS CSI Driver..."
          kubectl wait --for=condition=ready pod -l app.kubernetes.io/name=aws-ebs-csi-driver -n kube-system --timeout=300s
          
          echo "Pods do EBS CSI Driver:"
          kubectl get pods -n kube-system -l app.kubernetes.io/name=aws-ebs-csi-driver

      - name: Cria namespace monitoring
        run: |
          kubectl create namespace monitoring --dry-run=client -o yaml | kubectl apply -f -

      - name: Testa provisionamento de volume com PVC de teste
        run: |
          echo "Criando PVC de teste para verificar funcionamento..."
          cat <<EOF | kubectl apply -f -
          apiVersion: v1
          kind: PersistentVolumeClaim
          metadata:
            name: test-pvc
            namespace: monitoring
          spec:
            accessModes:
              - ReadWriteOnce
            resources:
              requests:
                storage: 1Gi
            storageClassName: gp2
          EOF
          
          # Aguarda um tempo e verifica status
          sleep 30
          kubectl get pvc test-pvc -n monitoring -o wide
          kubectl describe pvc test-pvc -n monitoring || true
          
          # Limpa teste
          kubectl delete pvc test-pvc -n monitoring --ignore-not-found

      - name: Cria PVC para Grafana
        run: |
          cat <<EOF | kubectl apply -f -
          apiVersion: v1
          kind: PersistentVolumeClaim
          metadata:
            name: grafana-pvc
            namespace: monitoring
          spec:
            accessModes:
              - ReadWriteOnce
            resources:
              requests:
                storage: 20Gi
            storageClassName: gp2
          EOF

      - name: Aguarda PVC estar Bound com timeout maior
        run: |
          echo "Aguardando PVC ser provisionado (pode levar alguns minutos)..."
          timeout 600 bash -c '
          while true; do
            STATUS=$(kubectl get pvc grafana-pvc -n monitoring -o jsonpath="{.status.phase}" 2>/dev/null || echo "Pending")
            echo "Status do PVC: $STATUS"
            if [ "$STATUS" = "Bound" ]; then
              echo "PVC está Bound!"
              break
            fi
            sleep 15
          done'
          
          echo "Detalhes do PVC:"
          kubectl get pvc grafana-pvc -n monitoring -o wide
          kubectl describe pvc grafana-pvc -n monitoring

      - name: Add Grafana Helm repo and update
        run: |
          helm repo add grafana https://grafana.github.io/helm-charts
          helm repo update

      - name: Install ou upgrade Grafana Helm chart
        run: |
          helm upgrade --install my-grafana grafana/grafana --namespace monitoring \
            --set persistence.enabled=true \
            --set persistence.size=20Gi \
            --set persistence.existingClaim=grafana-pvc \
            --set adminPassword=${{ secrets.GRAFANA_ADMIN_PASSWORD }} \
            --set service.type=LoadBalancer \
            --set service.annotations."service\.beta\.kubernetes\.io/aws-load-balancer-type"="nlb" \
            --wait --timeout=15m

      - name: Checa status recursos
        run: |
          echo "=== PODS ==="
          kubectl get pods -n monitoring
          echo "=== PVCs ==="
          kubectl get pvc -n monitoring -o wide
          echo "=== SERVICES ==="
          kubectl get svc -n monitoring
          echo "=== STORAGE CLASSES ==="
          kubectl get storageclass

      - name: Aguarda Grafana estar pronto
        run: |
          kubectl wait --for=condition=ready pod -l app.kubernetes.io/name=grafana -n monitoring --timeout=600s

      - name: Get Grafana LoadBalancer URL
        run: |
          echo "Aguardando LoadBalancer URL..."
          # Aguarda com polling ativo
          timeout 300 bash -c '
          while true; do
            GRAFANA_URL=$(kubectl get svc my-grafana -n monitoring -o jsonpath="{.status.loadBalancer.ingress[0].hostname}" 2>/dev/null)
            if [ -n "$GRAFANA_URL" ]; then
              echo "Grafana disponível em: http://$GRAFANA_URL"
              echo "::set-output name=grafana_url::$GRAFANA_URL"
              break
            fi
            echo "Aguardando LoadBalancer..."
            sleep 10
          done'
          echo "Detalhes do serviço:"
          kubectl get svc my-grafana -n monitoring -o wide

  # Job para troubleshooting
  troubleshoot:
    name: Troubleshooting
    runs-on: ubuntu-latest
    needs: [terraform-infrastructure, kubernetes-deployment]
    if: failure()
    
    steps:
      - name: Configura AWS credentials
        uses: aws-actions/configure-aws-credentials@v2
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Update kubeconfig
        run: |
          aws eks update-kubeconfig --name ${{ needs.terraform-infrastructure.outputs.cluster-name }} --region ${{ env.AWS_REGION }}

      - name: Coletar informações de debug
        run: |
          echo "=== EVENTOS DO NAMESPACE MONITORING ==="
          kubectl get events -n monitoring --sort-by='.lastTimestamp'
          
          echo "=== DETALHES DO EBS CSI DRIVER ==="
          kubectl get pods -n kube-system -l app.kubernetes.io/name=aws-ebs-csi-driver
          kubectl describe pods -n kube-system -l app.kubernetes.io/name=aws-ebs-csi-driver
          
          echo "=== LOGS DO EBS CSI CONTROLLER ==="
          kubectl logs -n kube-system -l app=ebs-csi-controller --container=ebs-plugin --tail=50 || true
          
          echo "=== LOGS DO EBS CSI NODE ==="
          kubectl logs -n kube-system -l app=ebs-csi-node --container=ebs-plugin --tail=50 || true